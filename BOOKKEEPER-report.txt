---------------------------------------------------------
--- STARTING PIPELINE FOR: BOOKKEEPER ---
---------------------------------------------------------
Opening existing repository: C:\Users\hp\Desktop\github_projects\BOOKKEEPER
Fetching project releases from JIRA for project BOOKKEEPER...
Found 11 valid and sorted releases for project BOOKKEEPER.
Successfully mapped 11 of 11 Jira releases to Git commits.
[Milestone 1, Step 1] Checking for Dataset...
Dataset already exists. Skipping generation.
[...] Preprocessing data for analysis...
Processed ARFF file already exists. Skipping preprocessing.
Checking for model file at path: C:\Users\hp\Desktop\datasets\BOOKKEEPER_best.model

[Milestone 2, Step 2-3] Found saved model. Loading from file: C:\Users\hp\Desktop\datasets\BOOKKEEPER_best.model
Starting data analysis to find actionable method...
[Milestone 2, Step 4 & 5] Finding Top Actionable Feature...
Identified Top Actionable Feature (AFeature): CyclomaticComplexity
[Milestone 2, Step 6] Identifying Target Method (AFMethod)...
  -> Searching within the last analyzed release: 4.2.1
  -> Found 216 buggy methods in this release.
Identified AFMethod (buggy method with highest CyclomaticComplexity):
  -> MethodName: bookkeeper-server/src/main/java/org/apache/bookkeeper/client/BKException.java/getMessage(int)
  -> CyclomaticComplexity Value: 25
[Milestone 2, Step 7] Saving AFMethod source code...
  -> Source code of AFMethod saved to: C:\Users\hp\Desktop\datasets\BOOKKEEPER_AFMethod.txt
  -> Refactoring file already exists at: C:\Users\hp\Desktop\AFMethod_refactored\BOOKKEEPER_AFMethod_refactored.txt
Data analysis completed.
[Milestone 2, Step 10] Starting What-If Simulation using AFeature: CyclomaticComplexity
[Milestone 2, Step 11] Training BClassifier on dataset A (BClassifierA)...
BClassifierA training completed successfully.
[Milestone 2, Step 12] Defect Prediction Summary Table:
DEBUG: Analyzing first 5 instances for prediction probabilities:
Instance 0: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 1: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 2: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 3: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 4: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
DEBUG: Analyzing first 5 instances for prediction probabilities:
Instance 0: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 1: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 2: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 3: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 4: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
DEBUG: Analyzing first 5 instances for prediction probabilities:
Instance 0: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 1: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 2: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 3: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 4: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
DEBUG: Analyzing first 5 instances for prediction probabilities:
Instance 0: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 1: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 2: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 3: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 4: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
+------------------------------------+-----------------+-------------------+
| Dataset                            | Total Instances | Predicted Defects |
+------------------------------------+-----------------+-------------------+
| A (Full Dataset)                   |           17255 |                 0 |
| B+ (CyclomaticComplexity > 0)      |            5967 |                 0 |
| B (B+ with CyclomaticComplexity=0) |            5967 |                 0 |
| C (CyclomaticComplexity <= 0)      |           11288 |                 0 |
+------------------------------------+-----------------+-------------------+
[PRELIMINARY QUESTIONS] Analyzing feature changes in AFMethod2 vs AFMethod...
DEBUG: Analyzing first 5 instances for prediction probabilities:
Instance 0: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 1: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 2: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 3: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 4: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
DEBUG: Analyzing first 5 instances for prediction probabilities:
Instance 0: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 1: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 2: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 3: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 4: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
--- PRELIMINARY ANALYSIS ---
Predicted defects in B+ (original with CyclomaticComplexity > 0): 0
Predicted defects in B (refactored with CyclomaticComplexity = 0): 0
QUESTION 1: NO - Predicted defects did not increase in AFMethod2 (0 vs 0).
QUESTION 2: NO CHANGE - Predicted defects remained the same in AFMethod2 (0).
This suggests the refactoring had no impact on predicted defect probability.
--- END PRELIMINARY ANALYSIS ---
[Milestone 2, Step 13] Calculating final metrics based on custom formulas...
DEBUG: Analyzing first 5 instances for prediction probabilities:
Instance 0: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 1: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 2: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 3: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Instance 4: actual_class=0.0, predicted_class=0.0, prob_no={:.3f}, prob_yes={:.3f}
Formula 1 (drop) = (actual B+ - expected B) / actual B+ = (568 - 0) / 568 = 1,000
ANSWER 1 (drop): The calculated metric value is 1,000.
Formula 2 (reduction) = (actual B+ - expected B) / actual A = (568 - 0) / 827 = 0,687
ANSWER 2 (reduction): The calculated metric value is 0,687.
Comparing methods:
  Original: C:\Users\hp\Desktop\datasets\BOOKKEEPER_AFMethod.txt
  Refactored: C:\Users\hp\Desktop\AFMethod_refactored\BOOKKEEPER_AFMethod_refactored.txt
Feature comparison results:
--- FINISHED PIPELINE FOR: BOOKKEEPER ---
